CMP 313 STUDY OF PDF

FORMAL GRAMMERS

What is a Grammar?
A "language" can be formally defined as "any system of formalized symbols, signs, etc. used for communication".

A "grammar" can be defined as "the set of structural rules that govern sentences, words, etc. in a natural language."

This is an important knowledge because computers don't understand English, French or Spanish, We use different 
languages to communicate with them (C, C++, Java, etc) - This language 


These are the step by step process pertaining to how the Compiler runs:
1. Source Code:       code is read from programmer.
2. Lexical Analyzer:  groups characters into words that make sense in the language
3. Syntax Analyzer:   check that the words/characters made form are syntactically correct sentences
4. Semantic Analyzer: check that the words and their meaning together actually make sense.


A Language "Parse Tree"

Sentence                           (Top-down parsing tree)
|
---------------------
|         |         |
|         |         |
Subject   |        object
|         |         |____________________
|         |         |         |         |
Noun     verb     article  adjective   noun
|         |         |         |         |
|         |         |         |         |
|         |         |         |         |
I        am         a        good    programmer


Top-down VS Bottom-up Parsing

Top-down starts with a "start-symbol" representing what you know you are translating, and deconstructs it using a set
of given possible rules (using left-side derivation) for that language to reach the sentence you have.

Bottom-up starts with the symbols in your sentence and tries to match them with valid representations in the language,
and uses right-side derivation to combine those to form other parts of the language, until eventually ending up 
with the start-symbol

Top-down is usually easy to make, but bottom-up usually works better (especially with computer programming).

Either way gives us a "true" or "false" output: whether or not the sentence is valid in the language used.


Example Grammer:
- Given the grammar (exp = start symbol)   note: exp short for expression
  exp   => A + A
  A     => digit | A * A
  digit => 0 | 1

Test on Sentence
check if "1*0+1" and "1+1+1*11" are valid.

Solution
Exp => A + A
    => A * A
    => digit * A + A
    => 1 * digit + A
    => 1 * 0 + A
    => 1 * 0 + 1 ✅


What is an Ambiguous Grammars?
This is a context-free grammar for which there exists a string that can have more than 1 parse tree

Not Good: This is when two completely different parse trees can be generated for the same sentence. Which means
the sentences can be different depending on how it is derived. The programmer might want it to mean one thing while
the computer thinks it means something else.

In short: if their are many ways to generate a sentence or string, the grammer is said to be ambiguous


Production Rules are also known as Grammers which both describe the structure of a language or it's syntax, 
but Production Rule is used in the context of formal languages only while Grammers is more broad refering also 
to the syntax of any language



Chapter 2
Derivations from a Grammar

Tip: 

- start symbol:        S
- nonterminal symbols: A, B, C ...
- terminal symbols:    a, b, c ...

- | : means or
- ɛ : means empty

The set of all strings that can be derived from a Grammar is said to be the LANGUAGE generated from that Grammar

Example 1: Consider the Grammar G1 = ({S,A}, {a,b}, S, {S → aAb, aA → aaAb, A → ɛ})
                                ⇣                   ⇣                           ⇣
                             grammar             start symbol                 epsilon (means empty/blank)

                Grammer/Production Rule
S → aAb         [by S → aAb]    
    ¯¯
  → aaAbb       [by aA → aaAb]
     ¯¯
  → aaaAbbb     [by aA → aaAb]
       ¯
  → aaabbb      [by A  → ɛ (means empty)]

  DONE - 'aaabbb' is a string that is derived from our Grammar G1 / Production Rule
       - Note: This is just one string that can be derived from G1 but the set of all the strings that can be derived
               from G1 is said to be the LANGUAGE


Example 2: G2 = ({S,A,B}, {a,b}, S, {S → AB, A → a, B→b})

S → AB          [by S → ab]
    ¯
  → aB          [by A → a]
     ¯
  → ab          [by B → b]
     
DONE - 'ab' is a string that is derived from our Grammar and is the LANGUAGE of our Grammer G2 (because 'ab' is 
       the only string that can be derived from G2)

L(G2) = {ab}    // This means the Language generated by G2 = {ab}



Example 3: G3 = ({S,A,B}, {a,b}, S, { S → AB, A → aA|a, B → bB|b })

S → AB       S → AB        S → a         S → AB
  → ab         → aAbBn       → aAb         → abB
               → aabb        → aab         → abb

L(G3) = {ab, a²b², a²b, ab², ...}  // ... means and so many others. We use replace aa with a² and bb with b²

Spin-off: A generalized way of writing th language generated by G3 above would be
      = {a^m, b^n | m ≥ 0 and n ≥ 0}  // we would have used m for both a and b symbols but some a's don't have ² and some do - same for b


Consider the grammar G where N={S,B}, Σ={a,b,c} , S is the start symbol, and P consists of the following 
production rules:

1. S → aBSc
2. S → abc
3. BA → aB
4. Bb → bb

This grammar defines the language
L(G) = {a^n b^n c^n|n ≥ 1}
where a^n denotes a string of n consecutive a's. Thus, the language is the set of strings 
that consist of 1 or more a's, followed by the same number of b's, followed by the 
same number of c's.






